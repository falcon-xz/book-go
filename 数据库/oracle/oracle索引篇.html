<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>oracle索引篇</title>
</head>
<script language="javascript">
</script>
<body>
<h4>oracle索引篇</h4>
<ul style=" list-style-type: decimal;">

	<li>创建索引<br/>
	使用速度 数值<字符串<日期<br/>
	一般索引是B*Tree索引,在索引结构中存储着键值和键值的RowID,并且是一一对应的<br/>
	create index index_name on tablename(colums...);<br/>
	<br/>
	特点:<br/>
	a.index需要储存空间和I/O操作。<br/>
	b.index的目的是加快select的速度的。<br/>
	c.insert,update,delete数据oracle会同时对索引进行相应的调整，因此会增加一定的消耗。<br/>
	d.查询占全表的30%以下，使用索引;否则回表+使用index的cost 比 全表扫的更大<br/>
	e.Index 对null 无效。<br/>
	<br/>
	
	使用:<br/>
	a.索引和表应该放在不同的表空间，在读取一个表时，记录和索引是同时读取，修改也同步进行，会引起竞争。<br/>
	b.索引空间是extent是大小应该是5 blocks的倍数，因为oracle是一次读出5个blocks，如果你的extends是6，就会造成2次I/O操作。<br/>
	c.在创建索引时可以关闭索引对应的redo 日志，提高速度。<br/>
	d.重建索引 &nbsp;&nbsp;
		alter index index_name rebuild [tablespace tablespace_name ]<br/>
	e.整理索引碎片，高效不锁表&nbsp;&nbsp;
		Alter index  index_name coalesce;<br/>
<br/>
	缺点:<br/>
	a.增加索引会降低INSERT语句的性能，因为需要同时对表和索引进行插入。<br/>
	b.索引列的UPDATE操作将会减慢执行速度，因为数据库必须管理对表和索引的改动。<br/>
	c.大量行的DELETE操作将会由于表中存在索引而减慢执行速度。<br/>
	</li>
	<br/>
	
	<li>通常所说的索引种类<br/>
	a.普通索引<br/>
	b.反向索引<br/>
	c.组合索引<br/>
	d.函数索引<br/>
	e.位图索引<br/>
	</li>
	<br/>
	
	<li>不走索引的原因<br/>
	a.隐式转换 <br/>
	b.你的表的统计信息(最可能的原因) 需要重新计算 手工分析<br/>
	c.数据量太小 cost优化器决定<br/>
	d.组合索引：查询谓词并未使用组合索引的第一列，此处有一个INDEX SKIP SCAN概念<br/>
	e.索引列包含有null值 使用select count(*) from table时不会使用索引<br/>
	f.在索引列上使用函数时不会使用索引，如果一定要使用索引只能建立函数索引。<br/>
	g.查询数据占总数据量百分比过大，回表查询cost过大<br/>
	h.索引列like 时 % 百分号在前 '%xx'<br/>
	i.<>条件<br/>
	j.修改字段类型导致索引失效 ,LONG修改为CLOB，居然会导致其他列的索引失效
	h.误删除表后恢复，索引名称改变<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;drop table emp2;<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;flashback table emp2 to before drop;<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;会影响hint语句的执行<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;查看着两个索引的名称<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;select * from user_indexes t1 where t1.TABLE_NAME='EMP2'<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;重命名<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;alter index "BIN$vk6WzSBMTq6MsKWXDL8feg==$0" rename to INDEX_EMP2_EMPNO<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;alter index "BIN$O8u7vzfTSXORRKnesiOZSw==$0" rename to INDEX_EMP2_DEPTNO<br/>

	</li>
	<br/>
	
	<li>组合索引与单列索引交叉的情况<br/>
	如果组合索引的前缀和单列索引一致，单列索引可以省略，同样可以走索引<br/>
		drop table t purge;<br/>
		create table t as select * from dba_objects;<br/>
		create index idx_object_id on t(object_id,object_type);<br/>
<br/>
		select * from t where object_id=19;<br/>
		select * from t where object_type='TABLE';<br/>
	</li>
	<br/>
	
	<li>监控索引的使用状态
	生成用户下所有监控索引语句<br/>
	select 'alter index '||index_name||' monitoring usage;' from user_indexes;<br/>
	生成用户下所有监控解除索引语句<br/>
	select 'alter index '||index_name||' nomonitoring usage;' from user_indexes;<br/>
	查看监控信息 主要是看USED 字段 使用为YES  没使用为NO <br/>
	select t.USED,t.* from v$object_usage t <br/>
	
	</li>
	<br/>
	
	
	<li>
	手工分析索引<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;a.分析索引的block中是否有坏块儿<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;analyze index idx_t validate structure：<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;b.统计索引的统计信息(全分析)，主要为CBO服务<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;analyze index idx_t compute statistics：<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;c.指定比例进行抽样分析，为CBO服务<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;analyze index idx_t estimate statistics sample 10 percent<br/>
	<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;之后查询<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;SELECT t.height,t.blocks,t.name,t.lf_rows,t.del_lf_rows,t.del_lf_rows/t.lf_rows FROM index_stats t<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;如果t.del_lf_rows/t.lf_rows 删除的数据占总数据的15%以上 ，需要重建或者整理索引碎片<br/>
	</li>
	<br/>
	
	<li>
	</li>
	<br/>
	</ul>

</body>

</html>
