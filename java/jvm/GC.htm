<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK" />
<title>内存回收 GC (garbage collection)</title>
<style>
div{
	padding-left:3%;
}
.divfirst{
	width:96%;
	background-color:#FFCC99;
}
.divnext{
	border-style: dotted;
	border-color: #C0C0C0;
	display:none;
	width:94%;
	margin-left:1%;
}

.table{
	
	width:100%;
	margin-left:10px;
	
}
.table tr td{
	text-align:left;
	border:1px solid black;
	padding-left:15px;
}
</style>
<script>
function hoverhidden(obj){
	//obj.nextSibling 获取下一个同辈元素
	var nextObj = obj.nextSibling ;
	if(nextObj.style.display=="block"){
		nextObj.style.display = "" ;
		obj.style.background = "#FFCC99"
	}else{
		nextObj.style.display = "block" ;
		obj.style.background = "#99FFCC"
	}
}
</script>
</head>

<body>
<h4></h4>
<div class="divfirst"  onclick="javascript:hoverhidden(this)">
Java堆中各代分布
</div>
<div class="divnext" >
	
	<img src="heap.jpg"/>
	<br />
	1.Young（年轻代）属于heap:<br />
	年轻代分三个区。一个Eden区，两个Survivor区。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制年老区(Tenured。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。
	<br /><br />
	2.Tenured（年老代）属于heap:<br />
	年老代存放从年轻代存活的对象。一般来说年老代存放的都是生命期较长的对象<br /><br />
	3.:Perm（持久代）属于MethodArea:<br />
	用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。<br /><br />
	
	
</div>
<h4></h4>
<div class="divfirst"  onclick="javascript:hoverhidden(this)">
	GC 算法
</div>
<div class="divnext">
<br />
	1.<span style=" color: #CC33FF;font-size:large">标记清除算法:</span><br />
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象；然后，在清除阶段，清除所有未被标记的对象。
	<br />
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的缺点就是效率比较低（递归与全堆对象遍历），导致stop the world的时间比较长，这种方式清理出来的空闲内存是不连续的，而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找<br />
	<br />
	2.<span style=" color: #CC33FF;font-size:large">复制算法（新生代的GC）:</span><br />
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。
	<br />
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;复制算法使得每次都只对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半;HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。
	<br /><br />
	3.<span style=" color: #CC33FF;font-size:large">标记-整理算法：（老年代的GC）:</span><br />
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记；但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端；之后，清理边界外所有的空间;如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。
	<br />
	
	<br /><br />
	4.<span style=" color: #CC33FF;font-size:large">分代收集算法：（新生代的GC+老年代的GC）:</span><br />
	只是根据对象的存活周期的不同将内存划分为几块儿。一般是把Java堆分为新生代和老年代：短命对象归为新生代，长命对象归为老年代。<br />
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;少量对象存活，适合复制算法：在新生代中，每次GC时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。<br />
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大量对象存活，适合用标记-清理/标记-整理：在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC。<br />
	<br />


</div>


<h4></h4>
<div class="divfirst"  onclick="javascript:hoverhidden(this)">
HotSpot JVM GC收集器
</div>
<div class="divnext">
<img src="GC.jpg"/><br />
<span style=" color: #CC33FF;font-size:large">Serial(串行GC)收集器</span><br />
Serial收集器是一个新生代收集器，单线程执行，使用复制算法。它在进行垃圾收集时，必须暂停其他所有的工作线程(用户线程)。是Jvm client模式下默认的新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率
<br /><br />
<span style=" color: #CC33FF;font-size:large">ParNew(并行GC)收集器</span><br />
ParNew收集器其实就是serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器一样。
<br /><br />
<span style=" color: #CC33FF;font-size:large">Parallel Scavenge(并行回收GC)收集器</span><br />
Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器。parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%
<br /><br />
<span style=" color: #CC33FF;font-size:large">Serial Old(串行GC)收集器</span><br />
Serial Old是Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。
<br /><br />
<span style=" color: #CC33FF;font-size:large">Parallel Old(并行GC)收集器</span><br />
Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。
<br /><br />
<span style=" color: #CC33FF;font-size:large">CMS(并发GC)收集器</span><br />

CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，整个收集过程大致分为4个步骤：<br />
①.初始标记(CMS initial mark)<br />
②.并发标记(CMS concurrenr mark)<br />
③.重新标记(CMS remark)<br />
④.并发清除(CMS concurrent sweep)<br />
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中初始标记、重新标记这两个步骤任然需要停顿其他用户线程。初始标记仅仅只是标记出GC ROOTS能直接关联到的对象，速度很快，并发标记阶段是进行GC ROOTS 根搜索算法阶段，会判定对象是否存活。而重新标记阶段则是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会被初始标记阶段稍长，但比并发标记阶段要短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以整体来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。<br />
 
 	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。CMS默认启动的回收线程数是：(CPU数量+3) / 4。<br />
 	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure“，失败后而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。这一部分垃圾称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分内存空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间时就会被激活，也可以通过参数-XX:CMSInitiatingOccupancyFraction的值来提供触发百分比，以降低内存回收次数提高性能。要是CMS运行期间预留的内存无法满足程序其他线程需要，就会出现“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置的过高将会很容易导致“Concurrent Mode Failure”失败，性能反而降低。<br />
 	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一个缺点，CMS是基于“标记-清除”算法实现的收集器，使用“标记-清除”算法收集后，会产生大量碎片。空间碎片太多时，将会给对象分配带来很多麻烦，比如说大对象，内存空间找不到连续的空间来分配不得不提前触发一次Full  GC。为了解决这个问题，CMS收集器提供了一个-XX:UseCMSCompactAtFullCollection开关参数，用于在Full  GC之后增加一个碎片整理过程，还可通过-XX:CMSFullGCBeforeCompaction参数设置执行多少次不压缩的Full  GC之后，跟着来一次碎片整理过程。
<br /><br />

<span style=" color: #CC33FF;font-size:large">G1收集器</span><br />
G1(Garbage First)收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。还有一个特点之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆(包括新生代，老年代)。
<br /><br />


</div>

<h4></h4>
<div class="divfirst"  onclick="javascript:hoverhidden(this)">
GC 参数说明
</div>
<div class="divnext" >
<span style=" color: #CC33FF;font-size:large">说明</span><br />
。

默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制，可以由-XX:MinHeapFreeRatio=指定。  
默认空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制，可以由-XX:MaxHeapFreeRatio=指定。

服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。
1) 布尔型参数选项：-XX:+ 打开， -XX:- 关闭。<br/>
2) 数字型参数选项通过-XX:=设定。数字可以是 m/M(兆字节)，k/K(千字节)，g/G(G字节)。比如：32K表示32768字节。<br/>
3) 字符行参数选项通过-XX:=设定，通常用来指定一个文件，路径，或者一个命令列表。<br/><br/>
<table class="table" style="margin-left:-2%">
	<tr style="background-color:lightgrey">
		<td style="width:40%"><b>参数</b></td>
		<td style="width:60%"><b>说明</b></td>
	</tr>
	<tr>
		<td style="width:40%">
		export JAVA_OPTS=%JAVA_OPTS% -Xms128m -Xmx512m<br/>
		java -jar xx.jar -Xms128m -Xmx512m
		</td>
		<td style="width:60%">如何加参数启动</td>
	</tr>
	
	<tr>
		<td colspan="2" style="width:100%;background-color:lightgrey;"><b>日志及打印</b></td>
	</tr>
	<tr>
		<td style="width:40%">-Xloggc:$path/gc.log-`date +%Y%m%d%H%M`<br/>
							-Xloggc:e:/gc.log</td>
		<td style="width:60%">linux 日志路径<br/>
								windows 日志路径</td>
	</tr>
	<tr>
		<td style="width:40%">-verbose:gc</td>
		<td style="width:60%">记录 GC 运行以及运行时间，一般用来查看 GC 是否是应用的瓶颈</td>
	</tr>
	<tr>
		<td style="width:40%">-XX:+PrintGCDetails</td>
		<td style="width:60%">记录 GC 运行时的详细数据信息，包括新生成对象的占用内存大小以及耗费时间等</td>
	</tr>
	<tr>
		<td style="width:40%">-XX:-PrintGCTimeStamps</td>
		<td style="width:60%">打印垃圾收集的时间戳</td>
	</tr>
	<tr>
		<td colspan="2" style="width:100%;background-color:lightgrey;"><b>heap堆大小 栈大小 相关</b></td>
	</tr>
	<tr>
		<td style="width:40%">-Xms1024m </td>
		<td style="width:60%">初始化堆内存大小 在32位操作系统上 heap 有1.5G-2G的限制，而64位的就没有</td>
	</tr>
	<tr>
		<td style="width:40%">-Xmx1024m</td>
		<td style="width:60%">堆内存最大值</td>
	</tr>
	<tr>
		<td style="width:40%">-Xmn256m</td>
		<td style="width:60%">新生代大小</td>
	</tr>
	<tr>
		<td style="width:40%">-Xss128k</td>
		<td style="width:60%">线程桟大小，JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右</td>
	</tr>
	<tr>
		<td style="width:40%">-XX:SurvivorRatio=4</td>
		<td style="width:60%">设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</td>
	</tr>
	<tr>
		<td style="width:40%"> -XX:NewRatio=4</td>
		<td style="width:60%">设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去永久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</td>
	</tr>
	<tr>
		<td colspan="2" style="width:100%;background-color:lightgrey;"><b>Perm Generation 永生代 相关</b></td>
	</tr>
	<tr>
		<td style="width:40%">-XX:PermSize=64m</td>
		<td style="width:60%">永生代最小值</td>
	</tr>
	<tr>
		<td style="width:40%">-XX:MaxPermSize=64m</td>
		<td style="width:60%">永生代最大值</td>
	</tr>
	<tr>
		<td colspan="2" style="width:100%;background-color:lightgrey;"><b>垃圾收集器行为</b></td>
	</tr>
	<tr>
		<td style="width:40%">-XX:+UseSerialGC</td>
		<td style="width:60%">使用Serial + Serial Old的收集器组合进行内存回收</td>
	</tr>
	<tr>
		<td style="width:40%">-XX:+UseParallelGC</td>
		<td style="width:60%">使用Parallel Scavenge +  Serial Old的收集器组合进行回收</td>
	</tr>
	<tr>
		<td style="width:40%">-XX:+UseParallelOldGC</td>
		<td style="width:60%">使用Parallel Scavenge +  Parallel Old的收集器组合进行回收</td>
	</tr>
	<tr>
		<td style="width:40%">-XX:+UseParNewGC</td>
		<td style="width:60%">使用ParNew + Serial Old的收集器进行垃圾回收</td>
	</tr>
	<tr>
		<td style="width:40%">-XX:+UseConcMarkSweepGC</td>
		<td style="width:60%">使用ParNew + CMS +  Serial Old的收集器组合进行内存回收，Serial Old作为CMS出现“Concurrent Mode Failure”失败后的后备收集器使用</td>
	</tr>
	<tr>
		<td style="width:40%">-XX:CMSInitiatingOccupancyFraction=70</td>
		<td style="width:60%">设置CMS收集器在老年代空间被使用多少后出发垃圾收集，默认值为68%，仅在CMS收集器时有效</td>
	</tr>
	<tr>
		<td style="width:40%">-XX:+UseCMSCompactAtFullCollection</td>
		<td style="width:60%">由于CMS收集器会产生碎片，此参数设置在垃圾收集器后是否需要一次内存碎片整理过程，仅在CMS收集器时有效</td>
	</tr>
	<tr>
		<td style="width:40%">-XX:+CMSFullGCBeforeCompaction</td>
		<td style="width:60%">设置CMS收集器在进行若干次垃圾收集后再进行一次内存碎片整理过程，通常与UseCMSCompactAtFullCollection参数一起使用</td>
	</tr>
	<tr>
		<td style="width:40%">-XX:+UseG1GC</td>
		<td style="width:60%">G1垃圾回收器</td>
	</tr>
</table>
</div>

<h4></h4>
<div class="divfirst"  onclick="javascript:hoverhidden(this)">
收集 java core , heap dump 
</div>
<div class="divnext">
<br/>
<h4>heap dump</h4>
<ul style=" list-style-type:;">
	<li>
		自动方式 :<br/>
		-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=${目录}<br/>
		当应用抛出OutOfMemoryError时自动在${目录}下生成dump文件
		<br/><br/>
	</li>
	<li>
		手动方式 :<br/>
		jmap -dump:format=b,file=a.hprof <pid><br/>

		file：保存路径及文件名<br/>
		pid：进程编号
		<br/><br/>
	</li>
</ul>
</div>

<h4></h4>
<div class="divfirst"  onclick="javascript:hoverhidden(this)">
test
</div>
<div class="divnext">content
</div>



</body>
</html>
